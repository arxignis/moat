use std::mem::MaybeUninit;
use std::sync::Arc;

use anyhow::anyhow;
use anyhow::{Context, Result};
use clap::Parser;
use http_body_util::Full;
use hyper::Uri;
use hyper::body::Bytes;
use hyper_util::client::legacy::Client;
use hyper_util::rt::{TokioExecutor, TokioTimer};
use libbpf_rs::skel::{OpenSkel, SkelBuilder};
use nix::net::if_::if_nametoindex;
use tokio::net::TcpListener;

pub mod access_log;
pub mod access_rules;
pub mod app_state;
pub mod arxignis;
pub mod cli;
pub mod config;
pub mod domain_filter;
pub mod firewall;
pub mod http;
pub mod proxy_utils;
pub mod ssl;
pub mod utils;
pub mod wirefilter;

pub mod bpf {
    // Include the skeleton generated by build.rs into OUT_DIR at compile time
    include!(concat!(env!("OUT_DIR"), "/filter.skel.rs"));
}

use tokio::signal;
use tokio::sync::watch;

use crate::app_state::AppState;
use crate::cli::Args;
use crate::domain_filter::DomainFilter;
use crate::ssl::{
    ProxyContext, SharedTlsState, TlsMode, install_ring_crypto_provider, load_custom_server_config,
    run_acme_http01_proxy, run_custom_tls_proxy, run_http_proxy,
};
use crate::arxignis::{ArxignisClient, ArxignisMode, CaptchaConfig, CaptchaProvider};
use crate::wirefilter::init_config;
use crate::utils::bpf_utils;

#[tokio::main]
async fn main() -> Result<()> {
    install_ring_crypto_provider()?;

    let args = Args::parse();

    // Initialize logger using CLI level
    {
        use env_logger::Env;
        let mut builder = env_logger::Builder::from_env(Env::default().default_filter_or("info"));
        builder.filter_level(args.log_level.to_level_filter());
        builder.format_timestamp_secs();
        builder.try_init().ok();
    }

    let iface_names: Vec<String> = {
        // Allow comma-separated interface list for compatibility with multi-iface builds.
        let parsed: Vec<String> = args
            .iface
            .split(',')
            .map(|iface| iface.trim())
            .filter(|iface| !iface.is_empty())
            .map(|iface| iface.to_string())
            .collect();
        if parsed.is_empty() {
            vec![args.iface.clone()]
        } else {
            parsed
        }
    };

    let mut skels: Vec<Arc<bpf::FilterSkel<'static>>> = Vec::new();
    let mut ifindices: Vec<i32> = Vec::new();

    if args.disable_xdp {
        log::info!("XDP disabled by --disable-xdp flag, skipping BPF attachment");
    } else {
        for iface in iface_names {
            let boxed_open: Box<MaybeUninit<libbpf_rs::OpenObject>> = Box::new(MaybeUninit::uninit());
            let open_object: &'static mut MaybeUninit<libbpf_rs::OpenObject> = Box::leak(boxed_open);
            let skel_builder = bpf::FilterSkelBuilder::default();
            match skel_builder.open(open_object).and_then(|o| o.load()) {
                Ok(mut skel) => {
                    let ifindex = match if_nametoindex(iface.as_str()) {
                        Ok(index) => index as i32,
                        Err(e) => {
                            log::error!("failed to get interface index for '{}': {e}", iface);
                            continue;
                        }
                    };
                    if let Err(e) = bpf_utils::bpf_attach_to_xdp(&mut skel, ifindex) {
                        log::error!("failed to attach XDP to '{}': {e}", iface);
                        continue;
                    }
                    log::info!("BPF successfully attached to XDP on {}", iface);
                    skels.push(Arc::new(skel));
                    ifindices.push(ifindex);
                }
                Err(e) => {
                    log::warn!("failed to load BPF skeleton for '{}': {e}", iface);
                }
            }
        }

        // Initialize access rules immediately after XDP attachment
        if !skels.is_empty() {
            let _ = access_rules::init_access_rules_from_global(&skels);
        }
    }

    if args.tls_mode == TlsMode::Custom
        && (args.tls_cert_path.is_none() || args.tls_key_path.is_none())
    {
        return Err(anyhow!(
            "--tls-cert-path and --tls-key-path are required for custom TLS mode",
        ));
    }
    let tls_state = SharedTlsState::new(
        args.tls_mode,
        args.acme_domains.clone(),
        args.tls_cert_path.as_ref().map(|p| p.display().to_string()),
    );

    let state = AppState {
        skels: skels.clone(),
        tls_state: tls_state.clone(),
    };

    let (shutdown_tx, shutdown_rx) = watch::channel(false);

    // Initialize wirefilter config
    if !args.arxignis_base_url.is_empty() && !args.arxignis_api_key.is_empty() {
        if let Err(e) = init_config(
            args.arxignis_base_url.clone(),
            args.arxignis_api_key.clone(),
        ).await {
            log::warn!("Failed to initialize HTTP filter with config: {}", e);
        }
    } else {
        log::warn!("No API credentials provided, HTTP filter will not be initialized");
    }

    let upstream_uri = {
        let upstream_str = args.upstream.as_ref()
            .ok_or_else(|| anyhow!("--upstream is required"))?;
        let parsed = upstream_str
            .parse::<Uri>()
            .context("failed to parse --upstream as URI")?;
        if parsed.scheme().is_none() || parsed.authority().is_none() {
            return Err(anyhow!(
                "upstream URI must be absolute (e.g. http://127.0.0.1:8081)",
            ));
        }
        parsed
    };

    // Start periodic access rules updater (if BPF is available)
    let access_rules_handle = if !state.skels.is_empty() {
        let skel_clone = state.skels.clone();
        let api_key = args.arxignis_api_key.clone();
        let base_url = args.arxignis_base_url.clone();
        let shutdown = shutdown_rx.clone();
        Some(access_rules::start_access_rules_updater(
            base_url, skel_clone, api_key, shutdown,
        ))
    } else {
        log::info!("Skipping access rules updater (XDP disabled)");
        None
    };

    let tls_handle = {
        let mut builder = Client::builder(TokioExecutor::new());
        builder.timer(TokioTimer::new());
        builder.pool_timer(TokioTimer::new());
        let client: Client<_, Full<Bytes>> = builder.build_http();

        // Create domain filter from CLI arguments
        // Use acme_domains as the whitelist (serves dual purpose)
        let domain_filter = DomainFilter::new(
            args.acme_domains.clone(),
            args.domain_wildcards.clone(),
        );

        if domain_filter.is_enabled() {
            log::info!(
                "Domain filtering enabled: {} domain(s), {} wildcard pattern(s)",
                args.acme_domains.len(),
                args.domain_wildcards.len()
            );
        }

        // Build Arxignis client and captcha config
        let captcha = CaptchaConfig {
            provider: args.captcha_provider.as_deref().and_then(CaptchaProvider::from_str),
            site_key: args.captcha_site_key.clone(),
            secret_key: args.captcha_secret_key.clone(),
            template_path: args.captcha_template_path.clone(),
            http_status_code: args.captcha_http_status_code,
        };
        let arx_mode = ArxignisMode::from_str(&args.arxignis_mode);
        let arx_client = ArxignisClient::new(
            args.arxignis_base_url.clone(),
            args.arxignis_api_key.clone(),
            arx_mode,
            captcha,
        ).ok();

        let proxy_ctx = Arc::new(ProxyContext {
            client,
            upstream: upstream_uri.clone(),
            domain_filter,
            tls_only: args.tls_only,
            arxignis: arx_client,
        });

        match args.tls_mode {
            TlsMode::Custom => {
                let cert = args.tls_cert_path.as_ref().unwrap();
                let key = args.tls_key_path.as_ref().unwrap();
                let config = load_custom_server_config(cert, key)?;
                let listener = TcpListener::bind(args.tls_addr)
                    .await
                    .context("failed to bind TLS socket")?;
                log::info!("HTTPS proxy listening on https://{}", args.tls_addr);
                let shutdown = shutdown_rx.clone();
                let tls_state_clone = tls_state.clone();
                let proxy_ctx_clone = proxy_ctx.clone();
                let skels_clone = state.skels.clone();
                Some(tokio::spawn(async move {
                    if let Err(err) = run_custom_tls_proxy(
                        listener,
                        config.clone(),
                        proxy_ctx_clone,
                        tls_state_clone,
                        skels_clone,
                        shutdown,
                    )
                    .await
                    {
                        log::error!("custom TLS proxy terminated: {err:?}");
                    }
                }))
            }
            TlsMode::Acme => {
                let http_listener = TcpListener::bind(args.http_addr)
                    .await
                    .context("failed to bind HTTP socket for ACME HTTP-01")?;
                let https_listener = TcpListener::bind(args.tls_addr)
                    .await
                    .context("failed to bind HTTPS socket")?;

                log::info!(
                    "HTTP server listening on http://{} (ACME HTTP-01 challenges + regular HTTP)",
                    args.http_addr
                );
                log::info!("HTTPS server (ACME) listening on https://{}", args.tls_addr);

                let tls_state_clone = tls_state.clone();
                let shutdown = shutdown_rx.clone();
                let args_clone = args.clone();
                let proxy_ctx_clone = proxy_ctx.clone();
                let skels_clone = state.skels.clone();
                Some(tokio::spawn(async move {
                    if let Err(err) = run_acme_http01_proxy(
                        https_listener,
                        http_listener,
                        &args_clone,
                        proxy_ctx_clone,
                        tls_state_clone,
                        skels_clone,
                        shutdown,
                    )
                    .await
                    {
                        log::error!("ACME HTTP-01 proxy terminated: {err:?}");
                    }
                }))
            }
            TlsMode::Disabled => {
                // HTTP proxy for disabled TLS mode
                let listener = TcpListener::bind(args.http_addr)
                    .await
                    .context("failed to bind HTTP socket")?;
                log::info!("HTTP proxy listening on http://{}", args.http_addr);
                let shutdown = shutdown_rx.clone();
                let proxy_ctx_clone = proxy_ctx.clone();
                let skels_clone = state.skels.clone();
                Some(tokio::spawn(async move {
                    if let Err(err) = run_http_proxy(
                        listener,
                        proxy_ctx_clone,
                        skels_clone,
                        shutdown,
                    )
                    .await
                    {
                        log::error!("HTTP proxy terminated: {err:?}");
                    }
                }))
            }
        }
    };

    signal::ctrl_c().await?;
    log::info!("Shutdown signal received, stopping servers...");
    let _ = shutdown_tx.send(true);

    if let Some(handle) = tls_handle
        && let Err(err) = handle.await
    {
        log::error!("TLS task join error: {err}");
    }

    if let Some(handle) = access_rules_handle
        && let Err(err) = handle.await
    {
        log::error!("access-rules task join error: {err}");
    }

    if !ifindices.is_empty() {
        log::info!(
            "BPF attached to {} interface(s); dropping skeletons will detach on shutdown",
            ifindices.len()
        );
    }

    Ok(())
}
