use std::mem::MaybeUninit;
use std::net::Ipv4Addr;
use std::str::FromStr;
use std::sync::Arc;

use anyhow::anyhow;
use anyhow::{Context, Result};
use clap::Parser;
use http_body_util::Full;
use hyper::Uri;
use hyper::body::Bytes;
use hyper_util::client::legacy::Client;
use hyper_util::rt::{TokioExecutor, TokioTimer};
use libbpf_rs::skel::{OpenSkel, SkelBuilder};
use libbpf_rs::{MapCore, MapFlags};
use nix::net::if_::if_nametoindex;
use tokio::net::TcpListener;

pub mod access_log;
pub mod access_rules;
pub mod app_state;
pub mod cli;
pub mod firewall;
pub mod http;
pub mod ssl;
pub mod utils;

pub mod bpf {
    // Include the skeleton generated by build.rs into OUT_DIR at compile time
    include!(concat!(env!("OUT_DIR"), "/filter.skel.rs"));
}

use tokio::signal;
use tokio::sync::watch;

use crate::app_state::AppState;
use crate::cli::Args;
use crate::ssl::{
    ProxyContext, SharedTlsState, TlsMode, install_ring_crypto_provider, load_custom_server_config,
    run_acme_http01_proxy, run_custom_tls_proxy,
};
use crate::utils::bpf_utils;

#[tokio::main]
async fn main() -> Result<()> {
    install_ring_crypto_provider()?;
    let args = Args::parse();

    let upstream_uri = match args.tls_mode {
        TlsMode::Disabled => None,
        _ => {
            let upstream = args
                .upstream
                .as_ref()
                .ok_or_else(|| anyhow!("--upstream is required when TLS mode is not disabled"))?;
            let parsed = upstream
                .parse::<Uri>()
                .context("failed to parse --upstream as URI")?;
            if parsed.scheme().is_none() || parsed.authority().is_none() {
                return Err(anyhow!(
                    "upstream URI must be absolute (e.g. http://127.0.0.1:8081)",
                ));
            }
            Some(parsed)
        }
    };

    if args.tls_mode == TlsMode::Custom
        && (args.tls_cert_path.is_none() || args.tls_key_path.is_none())
    {
        return Err(anyhow!(
            "--tls-cert-path and --tls-key-path are required for custom TLS mode",
        ));
    }

    let tls_state = SharedTlsState::new(
        args.tls_mode,
        args.acme_domains.clone(),
        args.tls_cert_path.as_ref().map(|p| p.display().to_string()),
    );

    let (shutdown_tx, shutdown_rx) = watch::channel(false);

    let boxed_open: Box<MaybeUninit<libbpf_rs::OpenObject>> = Box::new(MaybeUninit::uninit());
    let open_object: &'static mut MaybeUninit<libbpf_rs::OpenObject> = Box::leak(boxed_open);
    let skel_builder = bpf::FilterSkelBuilder::default();

    let state = match skel_builder.open(open_object).and_then(|o| o.load()) {
        Ok(mut skel) => {
            let ifindex = match if_nametoindex(args.iface.as_str()) {
                Ok(index) => index as i32,
                Err(e) => {
                    return Err(anyhow!(
                        "failed to get interface index for '{}': {e}",
                        args.iface
                    ));
                }
            };

            bpf_utils::bpf_attach_to_xdp(&mut skel, ifindex).unwrap();
            println!("BPF sucessfully attached to xdp");

            let block_ip: Ipv4Addr = Ipv4Addr::from_str("192.168.215.123").unwrap();

            let my_ip_key_bytes =
                &utils::bpf_utils::convert_ip_into_bpf_map_key_bytes(block_ip, 32);

            let map_val = 1_u8;

            skel.maps.recently_banned_ips.update(
                my_ip_key_bytes,
                &map_val.to_le_bytes(),
                MapFlags::ANY,
            )?;

            AppState {
                skel: Some(Arc::new(skel)),
                tls_state: tls_state.clone(),
            }
        }
        Err(e) => {
            eprintln!("WARN: failed to load BPF skeleton: {e}. Control endpoints will be limited.");
            AppState {
                skel: None,
                tls_state: tls_state.clone(),
            }
        }
    };

    // Start periodic access rules updater (if BPF is available)
    let access_rules_handle = {
        let skel_clone = state.skel.clone();
        let api_key = args.arxignis_api_key.clone();
        let rule_id = args.arxignis_rule_id.clone();
        let base_url = args.arxignis_base_url.clone();
        let shutdown = shutdown_rx.clone();
        Some(access_rules::start_access_rules_updater(
            base_url, skel_clone, api_key, rule_id, shutdown,
        ))
    };

    // let control_state = state.clone();
    // let control_shutdown = shutdown_rx.clone();
    // let control_handle = tokio::spawn(async move {
    //     if let Err(err) = run_control_plane(control_listener, control_state, control_shutdown).await
    //     {
    //         eprintln!("control-plane task terminated: {err:?}");
    //     }
    // });

    let tls_handle = if let (Some(upstream), TlsMode::Disabled) = (&upstream_uri, args.tls_mode) {
        unreachable!("TLS mode disabled but upstream parsed: {upstream}");
    } else if let Some(upstream) = upstream_uri.clone() {
        let mut builder = Client::builder(TokioExecutor::new());
        builder.timer(TokioTimer::new());
        builder.pool_timer(TokioTimer::new());
        let client: Client<_, Full<Bytes>> = builder.build_http();
        let proxy_ctx = Arc::new(ProxyContext { client, upstream });
        match args.tls_mode {
            TlsMode::Custom => {
                let cert = args.tls_cert_path.as_ref().unwrap();
                let key = args.tls_key_path.as_ref().unwrap();
                let config = load_custom_server_config(cert, key)?;
                let listener = TcpListener::bind(args.tls_addr)
                    .await
                    .context("failed to bind TLS socket")?;
                println!("HTTPS proxy listening on https://{}", args.tls_addr);
                let shutdown = shutdown_rx.clone();
                let tls_state_clone = tls_state.clone();
                let skel_clone = state.skel.clone();
                Some(tokio::spawn(async move {
                    if let Err(err) = run_custom_tls_proxy(
                        listener,
                        config.clone(),
                        proxy_ctx,
                        tls_state_clone,
                        skel_clone,
                        shutdown,
                    )
                    .await
                    {
                        eprintln!("custom TLS proxy terminated: {err:?}");
                    }
                }))
            }
            TlsMode::Acme => {
                // Bind both HTTP (for ACME challenges + regular HTTP) and HTTPS
                let http_listener = TcpListener::bind(args.http_addr)
                    .await
                    .context("failed to bind HTTP socket for ACME HTTP-01")?;
                let https_listener = TcpListener::bind(args.tls_addr)
                    .await
                    .context("failed to bind HTTPS socket")?;

                println!(
                    "HTTP server listening on http://{} (ACME HTTP-01 challenges + regular HTTP)",
                    args.http_addr
                );
                println!("HTTPS server (ACME) listening on https://{}", args.tls_addr);

                let tls_state_clone = tls_state.clone();
                let shutdown = shutdown_rx.clone();
                let args_clone = args.clone();
                let skel_clone = state.skel.clone();
                Some(tokio::spawn(async move {
                    if let Err(err) = run_acme_http01_proxy(
                        https_listener,
                        http_listener,
                        &args_clone,
                        proxy_ctx,
                        tls_state_clone,
                        skel_clone,
                        shutdown,
                    )
                    .await
                    {
                        eprintln!("ACME HTTP-01 proxy terminated: {err:?}");
                    }
                }))
            }
            TlsMode::Disabled => None,
        }
    } else {
        None
    };

    signal::ctrl_c().await?;
    println!("Shutdown signal received, stopping servers...");
    let _ = shutdown_tx.send(true);

    if let Some(handle) = tls_handle
        && let Err(err) = handle.await
    {
        eprintln!("TLS task join error: {err}");
    }

    if let Some(handle) = access_rules_handle
        && let Err(err) = handle.await
    {
        eprintln!("access-rules task join error: {err}");
    }

    // if let Err(err) = control_handle.await {
    //     eprintln!("control-plane join error: {err}");
    // }

    Ok(())
}

// #[tokio::main]
// async fn main() -> Result<()> {
//     let args = Args::parse();

//     let addr: SocketAddr = "0.0.0.0:8080".parse().unwrap();
//     let listener = TcpListener::bind(addr).await?;
//     println!("HTTP server listening on http://{addr}");
//     // Load and open BPF skeleton
//     // Allocate the open object on the heap and leak it to extend lifetime
//     let boxed_open: Box<MaybeUninit<libbpf_rs::OpenObject>> = Box::new(MaybeUninit::uninit());
//     let open_object: &'static mut MaybeUninit<libbpf_rs::OpenObject> = Box::leak(boxed_open);
//     let skel_builder = bpf::FilterSkelBuilder::default();

//     let state = match skel_builder.open(open_object).and_then(|o| o.load()) {
//         Ok(mut skel) => {
//             // Get ifindex from interface name
//             let ifindex = match if_nametoindex(args.iface.as_str()) {
//                 Ok(index) => index as i32,
//                 Err(e) => {
//                     eprintln!(
//                         "ERROR: failed to get interface index for '{}': {}",
//                         args.iface, e
//                     );
//                     panic!("failed to get interface index");
//                 }
//             };

//             // let link = skel.progs.firewall.attach_xdp(ifindex)?;
//             bpf_utils::bpf_attach_to_xdp(&mut skel, ifindex).unwrap();

//             AppState {
//                 skel: Some(std::sync::Arc::new(skel)),
//             }
//         }
//         Err(e) => {
//             eprintln!(
//                 "WARN: failed to load BPF skeleton: {e}. Endpoints will return 503 for map ops."
//             );
//             panic!("failed to load skeleton");
//         }
//     };

//     let block_ip: Ipv4Addr = Ipv4Addr::from_str("192.168.215.0").unwrap();

//     let my_ip_key_bytes = &utils::bpf_utils::convert_ip_into_bpf_map_key_bytes(block_ip, 32);

//     let map_val = 1_u8;

//     state
//         .skel
//         .as_ref()
//         .unwrap()
//         .maps
//         .recently_banned_ips
//         .update(my_ip_key_bytes, &map_val.to_le_bytes(), MapFlags::ANY)?;

//     loop {
//         tokio::select! {
//             res = listener.accept() => {
//                 let (stream, peer) = match res {
//                     Ok(s) => s,
//                     Err(e) => { eprintln!("accept error: {e}"); continue; }
//                 };

//                 let state = state.clone();
//                 tokio::spawn(async move {
//                     let io = TokioIo::new(stream);
//                     if let Err(e) = http1::Builder::new()
//                         .serve_connection(io, service_fn(move |req| handle(req, peer, state.clone())))
//                         .with_upgrades()
//                         .await
//                     {
//                         eprintln!("connection error from {peer}: {e}");
//                     }
//                 });
//             }
//             _ = tokio::signal::ctrl_c() => {
//                 println!("Shutting down HTTP server (Ctrl-C) ...");
//                 break;
//             }
//         }
//     }

//     Ok(())
// }
