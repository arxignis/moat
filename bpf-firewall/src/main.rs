use std::convert::Infallible;
use std::mem::MaybeUninit;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::str::FromStr;

use anyhow::Result;
use clap::Parser;
use http_body_util::{BodyExt, Full};
use hyper::body::Bytes;
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::{Method, Request, Response};
use hyper_util::rt::TokioIo;
use libbpf_rs::skel::{OpenSkel, Skel, SkelBuilder};
use libbpf_rs::{MapCore, MapFlags};
use nix::net::if_::if_nametoindex;
use serde::Deserialize;
use tokio::net::TcpListener;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// The network interface to attach the XDP program to
    #[arg(short, long)]
    iface: String,
}

mod bpf {
    // Include the skeleton generated by build.rs into OUT_DIR at compile time
    include!(concat!(env!("OUT_DIR"), "/filter.skel.rs"));
}

#[allow(clippy::wildcard_imports)]
use bpf::*;

#[derive(Clone)]
struct AppState<'a> {
    skel: Option<std::sync::Arc<bpf::FilterSkel<'a>>>,
}

fn ipv4_to_u32_be(ip: Ipv4Addr) -> u32 {
    u32::from_be_bytes(ip.octets())
}

#[repr(C)]
#[derive(Clone, Copy)]
struct LpmKey {
    prefixlen: u32,
    addr: u32, // network byte order
}

fn header_json() -> (hyper::header::HeaderName, hyper::header::HeaderValue) {
    (
        hyper::header::CONTENT_TYPE,
        hyper::header::HeaderValue::from_static("application/json"),
    )
}

fn parse_cidr_param(req: &Request<hyper::body::Incoming>) -> Result<(Ipv4Addr, u32), String> {
    let uri = req.uri();
    let query = uri.query().unwrap_or("");
    for pair in query.split('&') {
        if let Some((k, v)) = pair.split_once('=') {
            if k == "target" {
                if let Some((ip_str, prefix_str)) = v.split_once('/') {
                    let ip = ip_str
                        .parse::<Ipv4Addr>()
                        .map_err(|_| "invalid ip in cidr".to_string())?;
                    let prefixlen = prefix_str
                        .parse::<u32>()
                        .map_err(|_| "invalid prefix in cidr".to_string())?;
                    if prefixlen > 32 {
                        return Err("prefixlen cannot be greater than 32".to_string());
                    }
                    return Ok((ip, prefixlen));
                } else {
                    let ip = v
                        .parse::<Ipv4Addr>()
                        .map_err(|_| "invalid ip".to_string())?;
                    return Ok((ip, 32)); // Default to /32 for a single IP
                }
            }
        }
    }
    Err("missing target parameter".to_string())
}

async fn handle(
    req: Request<hyper::body::Incoming>,
    peer: SocketAddr,
    state: AppState<'_>,
) -> Result<Response<Full<Bytes>>, Infallible> {
    println!("src ip: {}", peer.ip().to_string());
    let path = req.uri().path();
    let method = req.method();

    // Helper to build JSON responses
    let json = |s: &str| -> Response<Full<Bytes>> {
        let mut r = Response::new(Full::<Bytes>::from(Bytes::from(format!("{}\n", s))));
        let (k, v) = header_json();
        r.headers_mut().insert(k, v);
        r
    };

    let peer_ip = peer.ip();
    if let IpAddr::V4(block_ip) = peer_ip {
        let block_ip_u32: u32 = block_ip.into();
        let block_ip_be = block_ip_u32.to_be();

        let my_ip_key: types::lpm_key = types::lpm_key {
            prefixlen: 32_u32,
            addr: block_ip_be,
        };

        let my_ip_key_bytes = unsafe { plain::as_bytes(&my_ip_key) };

        if let Some(flag) = state
            .clone()
            .skel
            .unwrap()
            .maps
            .recently_banned_ips
            .lookup(my_ip_key_bytes, MapFlags::ANY)
            .unwrap()
        {
            println!("result of recently banned ip lookup: {:?}", flag);
            if flag == vec![1_u8] {
                return Ok(Response::new(Full::<Bytes>::from(Bytes::from(
                    "HAAAAAAHAHAHAAAAA....YOU HAVE ENTERED MY DUNGEON....you will not leave here alive (you have been banned)",
                ))));
            }
        }
    }

    // Root: health
    if path == "/" && method == hyper::Method::GET {
        let body = format!(
            "{{\"status\":\"ok\",\"service\":\"bpf-firewall\",\"remote_addr\":\"{}\"}}",
            peer.ip()
        );
        return Ok(json(&body));
    }

    // POST /ban with JSON body {"ips":["1.2.3.4", ...]}
    if path == "/ban" && method == &Method::POST {
        #[derive(Deserialize)]
        struct BanBody {
            ips: Vec<String>,
        }

        let Some(skel) = state.skel.as_ref() else {
            let mut r = json("{\"ok\":false,\"error\":\"bpf not loaded\"}");
            *r.status_mut() = hyper::StatusCode::SERVICE_UNAVAILABLE;
            return Ok(r);
        };

        // Aggregate body
        let bytes = match req.into_body().collect().await {
            Ok(c) => c.to_bytes(),
            Err(e) => {
                let mut r = json(&format!(
                    "{{\"ok\":false,\"error\":\"body read error: {}\"}}",
                    e
                ));
                *r.status_mut() = hyper::StatusCode::BAD_REQUEST;
                return Ok(r);
            }
        };
        let parsed: Result<BanBody, _> = serde_json::from_slice(&bytes);
        let body = match parsed {
            Ok(v) => v,
            Err(e) => {
                let mut r = json(&format!(
                    "{{\"ok\":false,\"error\":\"invalid json: {}\"}}",
                    e
                ));
                *r.status_mut() = hyper::StatusCode::BAD_REQUEST;
                return Ok(r);
            }
        };

        let mut ok = 0usize;
        let mut errs: Vec<(String, String)> = Vec::new();
        for s in body.ips {
            match s.parse::<Ipv4Addr>() {
                Ok(ip) => {
                    let key = LpmKey {
                        prefixlen: 32,
                        addr: ipv4_to_u32_be(ip),
                    };
                    let key_bytes: &[u8] = unsafe { plain::as_bytes(&key) };
                    let one: u8 = 1;
                    if let Err(e) =
                        skel.maps
                            .banned_ips
                            .update(key_bytes, &[one], libbpf_rs::MapFlags::ANY)
                    {
                        errs.push((ip.to_string(), e.to_string()));
                    } else {
                        let _ = skel.maps.recently_banned_ips.delete(key_bytes);
                        ok += 1;
                    }
                }
                Err(_) => errs.push((s, "invalid ip".to_string())),
            }
        }

        let mut resp = format!("{{\"ok\":true,\"banned_count\":{},\"errors\":[", ok);
        for (i, (ip, err)) in errs.iter().enumerate() {
            if i > 0 {
                resp.push(',');
            }
            resp.push_str(&format!(
                "{{\"ip\":\"{}\",\"error\":\"{}\"}}",
                ip,
                err.replace('"', "'")
            ));
        }
        resp.push_str("]}");
        return Ok(json(&resp));
    }

    // PUT /ban?target=1.2.3.4/24
    if path == "/ban" && method == hyper::Method::PUT {
        let resp = match parse_cidr_param(&req) {
            Ok((ip, prefixlen)) => {
                let key = LpmKey {
                    prefixlen,
                    addr: ipv4_to_u32_be(ip),
                };
                let key_bytes: &[u8] = unsafe { plain::as_bytes(&key) };
                let one: u8 = 1; // presence flag
                // Update banned, remove from recently
                let Some(skel) = state.skel.as_ref() else {
                    let mut r = json("{\"ok\":false,\"error\":\"bpf not loaded\"}");
                    *r.status_mut() = hyper::StatusCode::SERVICE_UNAVAILABLE;
                    return Ok(r);
                };
                let res_upd =
                    skel.maps
                        .banned_ips
                        .update(key_bytes, &[one], libbpf_rs::MapFlags::ANY);
                if let Err(e) = res_upd {
                    let mut r = json(&format!(
                        "{{\"ok\":false,\"error\":\"failed to ban: {}\"}}",
                        e
                    ));
                    *r.status_mut() = hyper::StatusCode::INTERNAL_SERVER_ERROR;
                    return Ok(r);
                }
                let _ = skel.maps.recently_banned_ips.delete(key_bytes);
                json(&format!(
                    "{{\"ok\":true,\"banned\":\"{}/{}\"}}",
                    ip, prefixlen
                ))
            }
            Err(e) => {
                let mut r = json(&format!("{{\"ok\":false,\"error\":\"{}\"}}", e));
                *r.status_mut() = hyper::StatusCode::BAD_REQUEST;
                r
            }
        };
        return Ok(resp);
    }

    // PUT /recently-ban?target=1.2.3.4/24
    if path == "/recently-ban" && method == hyper::Method::PUT {
        let resp = match parse_cidr_param(&req) {
            Ok((ip, prefixlen)) => {
                let key = LpmKey {
                    prefixlen,
                    addr: ipv4_to_u32_be(ip),
                };
                let key_bytes: &[u8] = unsafe { plain::as_bytes(&key) };
                let one: u8 = 1;
                let Some(skel) = state.skel.as_ref() else {
                    let mut r = json("{\"ok\":false,\"error\":\"bpf not loaded\"}");
                    *r.status_mut() = hyper::StatusCode::SERVICE_UNAVAILABLE;
                    return Ok(r);
                };
                let res_upd = skel.maps.recently_banned_ips.update(
                    key_bytes,
                    &[one],
                    libbpf_rs::MapFlags::ANY,
                );
                if let Err(e) = res_upd {
                    let mut r = json(&format!(
                        "{{\"ok\":false,\"error\":\"failed to set recently-banned: {}\"}}",
                        e
                    ));
                    *r.status_mut() = hyper::StatusCode::INTERNAL_SERVER_ERROR;
                    return Ok(r);
                }
                let _ = skel.maps.banned_ips.delete(key_bytes);
                json(&format!(
                    "{{\"ok\":true,\"recently_banned\":\"{}/{}\"}}",
                    ip, prefixlen
                ))
            }
            Err(e) => {
                let mut r = json(&format!("{{\"ok\":false,\"error\":\"{}\"}}", e));
                *r.status_mut() = hyper::StatusCode::BAD_REQUEST;
                r
            }
        };
        return Ok(resp);
    }

    // GET /status?target=1.2.3.4
    if path == "/status" && method == hyper::Method::GET {
        let resp = match parse_cidr_param(&req) {
            Ok((ip, prefixlen)) => {
                let key = LpmKey {
                    prefixlen,
                    addr: ipv4_to_u32_be(ip),
                };
                let key_bytes: &[u8] = unsafe { plain::as_bytes(&key) };
                let Some(skel) = state.skel.as_ref() else {
                    let mut r = json("{\"ok\":false,\"error\":\"bpf not loaded\"}");
                    *r.status_mut() = hyper::StatusCode::SERVICE_UNAVAILABLE;
                    return Ok(r);
                };
                let b = skel
                    .maps
                    .banned_ips
                    .lookup(key_bytes, libbpf_rs::MapFlags::ANY);
                let r = skel
                    .maps
                    .recently_banned_ips
                    .lookup(key_bytes, libbpf_rs::MapFlags::ANY);
                let in_banned = b.as_ref().map(|o| o.is_some()).unwrap_or(false);
                let in_recent = r.as_ref().map(|o| o.is_some()).unwrap_or(false);
                json(&format!(
                    "{{\"ok\":true,\"ip\":\"{}\",\"banned\":{},\"recently_banned\":{}}}",
                    ip, in_banned, in_recent
                ))
            }
            Err(e) => {
                let mut r = json(&format!("{{\"ok\":false,\"error\":\"{}\"}}", e));
                *r.status_mut() = hyper::StatusCode::BAD_REQUEST;
                r
            }
        };
        return Ok(resp);
    }

    // Fallback 404
    let mut not_found = json("{\"ok\":false,\"error\":\"not found\"}");
    *not_found.status_mut() = hyper::StatusCode::NOT_FOUND;
    Ok(not_found)
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    let addr: SocketAddr = "0.0.0.0:8080".parse().unwrap();
    let listener = TcpListener::bind(addr).await?;
    println!("HTTP server listening on http://{addr}");
    // Load and open BPF skeleton
    // Allocate the open object on the heap and leak it to extend lifetime
    let boxed_open: Box<MaybeUninit<libbpf_rs::OpenObject>> = Box::new(MaybeUninit::uninit());
    let open_object: &'static mut MaybeUninit<libbpf_rs::OpenObject> = Box::leak(boxed_open);
    let skel_builder = bpf::FilterSkelBuilder::default();

    let state = match skel_builder.open(open_object).and_then(|o| o.load()) {
        Ok(mut skel) => {
            // Get ifindex from interface name
            let ifindex = match if_nametoindex(args.iface.as_str()) {
                Ok(index) => index as i32,
                Err(e) => {
                    eprintln!(
                        "ERROR: failed to get interface index for '{}': {}",
                        args.iface, e
                    );
                    panic!("failed to get interface index");
                }
            };

            // let link = skel.progs.firewall.attach_xdp(ifindex)?;
            match skel.progs.firewall.attach_xdp(ifindex) {
                Ok(link) => {
                    skel.links = bpf::FilterLinks {
                        firewall: Some(link),
                    };
                    println!(
                        "Successfully attached XDP program to interface '{}' (ifindex: {})",
                        args.iface, ifindex
                    );
                }
                Err(e) => {
                    panic!(
                        "FATAL: Failed to attach XDP program. Your environment may not support it. Error: {}",
                        e
                    );
                }
            }

            AppState {
                skel: Some(std::sync::Arc::new(skel)),
            }
        }
        Err(e) => {
            eprintln!(
                "WARN: failed to load BPF skeleton: {e}. Endpoints will return 503 for map ops."
            );
            panic!("failed to load skeleton");
        }
    };

    let block_ip: Ipv4Addr = Ipv4Addr::from_str("192.168.215.0").unwrap();
    let block_ip_u32: u32 = block_ip.into();
    let block_ip_be = block_ip_u32.to_be();

    let my_ip_key: types::lpm_key = types::lpm_key {
        prefixlen: 8_u32, // change this lateeer...
        addr: block_ip_be,
    };

    let my_ip_key_bytes = unsafe { plain::as_bytes(&my_ip_key) };

    let map_val = 1_u8;

    state
        .skel
        .as_ref()
        .unwrap()
        .maps
        .recently_banned_ips
        .update(my_ip_key_bytes, &map_val.to_le_bytes(), MapFlags::ANY)?;

    loop {
        tokio::select! {
            res = listener.accept() => {
                let (stream, peer) = match res {
                    Ok(s) => s,
                    Err(e) => { eprintln!("accept error: {e}"); continue; }
                };

                let state = state.clone();
                tokio::spawn(async move {
                    let io = TokioIo::new(stream);
                    if let Err(e) = http1::Builder::new()
                        .serve_connection(io, service_fn(move |req| handle(req, peer, state.clone())))
                        .with_upgrades()
                        .await
                    {
                        eprintln!("connection error from {peer}: {e}");
                    }
                });
            }
            _ = tokio::signal::ctrl_c() => {
                println!("Shutting down HTTP server (Ctrl-C) ...");
                break;
            }
        }
    }

    Ok(())
}
