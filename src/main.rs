use std::mem::MaybeUninit;
use std::sync::Arc;
use std::str::FromStr;
use std::net::SocketAddr;
use std::fs::File;

use anyhow::anyhow;
use anyhow::{Context, Result};
use clap::Parser;
use daemonize::Daemonize;
use http_body_util::Full;
use hyper::Uri;
use hyper::body::Bytes;
use hyper_util::client::legacy::Client;
use hyper_util::rt::{TokioExecutor, TokioTimer};
use libbpf_rs::skel::{OpenSkel, SkelBuilder};
use nix::net::if_::if_nametoindex;
use tokio::net::TcpListener;

pub mod access_log;
pub mod access_rules;
pub mod actions;
pub mod config;
pub mod app_state;
pub mod cli;
pub mod content_scanning;
pub mod domain_filter;
pub mod firewall;
pub mod http;
pub mod http_client;
pub mod utils;
pub mod wirefilter;
pub mod proxy_utils;
pub mod threat;
pub mod redis;
pub mod proxy_protocol;
pub mod authcheck;

pub mod bpf {
    // Include the skeleton generated by build.rs into OUT_DIR at compile time
    include!(concat!(env!("OUT_DIR"), "/filter.skel.rs"));
}

pub mod bpf_stats;
pub mod tcp_fingerprint;
pub mod ja4_plus;
pub mod event_queue;

use tokio::signal;
use tokio::sync::watch;

use crate::app_state::AppState;
use crate::bpf_stats::BpfStatsCollector;
use crate::tcp_fingerprint::TcpFingerprintCollector;
use crate::tcp_fingerprint::TcpFingerprintConfig;
use crate::cli::{Args, Config};
use crate::domain_filter::DomainFilter;
use crate::http::{
    SharedTlsState, TlsMode, install_ring_crypto_provider, load_custom_server_config,
    run_acme_http01_proxy, run_custom_tls_proxy, run_http_proxy,
};
use crate::http::health_checks::start_health_check_server;
use crate::wirefilter::init_config;
use crate::content_scanning::{init_content_scanner, ContentScanningConfig};
use crate::utils::bpf_utils;
use crate::actions::captcha::{CaptchaConfig, CaptchaProvider, init_captcha_client, start_cache_cleanup_task};
use crate::access_log::{LogSenderConfig, set_log_sender_config};
use crate::event_queue::start_batch_event_processor;
use crate::authcheck::validate_api_key;
use crate::http_client::init_global_client;

fn main() -> Result<()> {
    install_ring_crypto_provider()?;

    let args = Args::parse();

    // Validate required arguments when no config file is provided
    if args.config.is_none() {
        if args.upstream.is_none() {
            return Err(anyhow::anyhow!("--upstream is required when no config file is provided"));
        }
        if args.arxignis_api_key.is_none() {
            return Err(anyhow::anyhow!("--arxignis-api-key is required when no config file is provided"));
        }
    }

    // Load configuration
    let config = Config::load_from_args(&args)
        .context("Failed to load configuration")?;

    // Handle daemonization before starting tokio runtime
    if config.daemon.enabled {
        let stdout = File::create(&config.daemon.stdout)
            .with_context(|| format!("Failed to create stdout file: {}", config.daemon.stdout))?;
        let stderr = File::create(&config.daemon.stderr)
            .with_context(|| format!("Failed to create stderr file: {}", config.daemon.stderr))?;

        let mut daemonize = Daemonize::new()
            .pid_file(&config.daemon.pid_file)
            .chown_pid_file(config.daemon.chown_pid_file)
            .working_directory(&config.daemon.working_directory)
            .stdout(stdout)
            .stderr(stderr);

        if let Some(user) = &config.daemon.user {
            daemonize = daemonize.user(user.as_str());
        }

        if let Some(group) = &config.daemon.group {
            daemonize = daemonize.group(group.as_str());
        }

        match daemonize.start() {
            Ok(_) => {
                // We're now in the daemon process, continue with application startup
            }
            Err(e) => {
                eprintln!("Failed to daemonize: {}", e);
                return Err(anyhow::anyhow!("Daemonization failed: {}", e));
            }
        }
    }

    // Initialize logger using CLI level
    // Note: env_logger writes to stderr by default, which is standard practice
    {
        use env_logger::Env;
        let mut builder = env_logger::Builder::from_env(Env::default().default_filter_or("info"));
        builder.filter_level(args.log_level.to_level_filter());
        builder.format_timestamp_secs();

        // In daemon mode, write to stdout instead of stderr for better log separation
        if config.daemon.enabled {
            builder.target(env_logger::Target::Stdout);
        }

        builder.try_init().ok();
    }

    // Start the tokio runtime and run the async application
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()?
        .block_on(async_main(args, config))
}

#[allow(clippy::too_many_lines)]
async fn async_main(args: Args, config: Config) -> Result<()> {

    if config.daemon.enabled {
        log::info!("Running in daemon mode (PID file: {})", config.daemon.pid_file);
    }

    // Initialize global HTTP client with keepalive configuration
    if let Err(e) = init_global_client() {
        log::warn!("Failed to initialize global HTTP client: {}", e);
    } else {
        log::info!("Global HTTP client initialized with keepalive configuration");
    }


    let iface_names: Vec<String> = if !config.network.ifaces.is_empty() {
        config.network.ifaces.clone()
    } else {
        vec![config.network.iface.clone()]
    };

    let mut skels: Vec<Arc<bpf::FilterSkel<'static>>> = Vec::new();
    let mut ifindices: Vec<i32> = Vec::new();

    if config.network.disable_xdp {
        log::info!("XDP disabled by config, skipping BPF attachment");
    } else {
        for iface in iface_names {
            let boxed_open: Box<MaybeUninit<libbpf_rs::OpenObject>> = Box::new(MaybeUninit::uninit());
            let open_object: &'static mut MaybeUninit<libbpf_rs::OpenObject> = Box::leak(boxed_open);
            let skel_builder = bpf::FilterSkelBuilder::default();
            match skel_builder.open(open_object).and_then(|o| o.load()) {
                Ok(mut skel) => {
                    let ifindex = match if_nametoindex(iface.as_str()) {
                        Ok(index) => index as i32,
                        Err(e) => {
                            log::error!("failed to get interface index for '{}': {e}", iface);
                            continue;
                        }
                    };
                    if let Err(e) = bpf_utils::bpf_attach_to_xdp(&mut skel, ifindex) {
                        log::error!("Failed to attach XDP to '{}': {}", iface, e);
                        log::info!("Hint: If IPv6 is not available, you can either enable it or set 'disable_xdp: true' in config.yaml");
                        continue;
                    }
                    log::info!("BPF sucessfully attached to xdp on {}", iface);
                    skels.push(Arc::new(skel));
                    ifindices.push(ifindex);
                }
                Err(e) => {
                    log::warn!("failed to load BPF skeleton for '{}': {e}", iface);
                }
            }
        }

        // Initialize access rules immediately after XDP attachment
        if !skels.is_empty() {
            let _ = access_rules::init_access_rules_from_global(&skels);
        }
    }

    // Convert config TLS mode string to enum
    let tls_mode = TlsMode::from_str(&config.tls.mode)
        .context("Invalid TLS mode in config")?;

    if tls_mode == TlsMode::Custom
        && (config.tls.cert_path.is_none() || config.tls.key_path.is_none())
    {
        return Err(anyhow!(
            "cert_path and key_path are required for custom TLS mode in config",
        ));
    }

    // Expand wildcard domains into specific domains for TLS and filtering
    let expanded_domains = DomainFilter::expand_wildcard_domains(&config.acme.domains);
    log::info!("Expanded {} domains into {} specific domains",
               config.acme.domains.len(), expanded_domains.len());

    let tls_state = SharedTlsState::new(
        tls_mode,
        expanded_domains.clone(),
        config.tls.cert_path.as_ref().map(|p| p.clone()),
    );

    // Create BPF statistics collector
    let bpf_stats_collector = BpfStatsCollector::new(skels.clone(), config.bpf_stats.enabled);

    // Create TCP fingerprinting collector
    let tcp_fingerprint_collector = TcpFingerprintCollector::new_with_config(
        skels.clone(),
        TcpFingerprintConfig::from_cli_config(&config.tcp_fingerprint)
    );

    let state = AppState {
        skels: skels.clone(),
        tls_state: tls_state.clone(),
        ifindices: ifindices.clone(),
        bpf_stats_collector,
        tcp_fingerprint_collector,
    };


    let (shutdown_tx, shutdown_rx) = watch::channel(false);

    // Initialize Redis manager if Redis URL is provided
    if !config.redis.url.is_empty() {
        if let Err(e) = redis::RedisManager::init(&config.redis.url, config.redis.prefix.clone()).await {
            log::warn!("Failed to initialize Redis manager: {}", e);
        } else {
            log::info!("Redis manager initialized successfully");
        }
    }

    // Validate API key if provided
    if !config.arxignis.base_url.is_empty() && !config.arxignis.api_key.is_empty() {
        if let Err(e) = validate_api_key(
            &config.arxignis.base_url,
            &config.arxignis.api_key,
        ).await {
            log::error!("API key validation failed: {}", e);
            return Err(anyhow::anyhow!("API key validation failed: {}", e));
        }
    }

    // Build list of interfaces to attach
    if !config.arxignis.base_url.is_empty() && !config.arxignis.api_key.is_empty() {
        if let Err(e) = init_config(
            config.arxignis.base_url.clone(),
            config.arxignis.api_key.clone(),
        ).await {
            log::warn!("Failed to initialize HTTP filter with config: {}", e);
        }

        // Initialize threat intelligence client
        if let Err(e) = threat::init_threat_client(
            config.arxignis.base_url.clone(),
            config.arxignis.api_key.clone(),
        ).await {
            log::warn!("Failed to initialize threat client: {}", e);
        } else {
            log::info!("Threat intelligence client initialized");
            // Start cache cleanup task
            threat::start_cache_cleanup_task().await;
        }

        // Initialize captcha client if configuration is provided
        if let (Some(site_key), Some(secret_key), Some(jwt_secret)) = (
            &config.arxignis.captcha.site_key,
            &config.arxignis.captcha.secret_key,
            &config.arxignis.captcha.jwt_secret
        ) {
            let captcha_config = CaptchaConfig {
                site_key: site_key.clone(),
                secret_key: secret_key.clone(),
                jwt_secret: jwt_secret.clone(),
                provider: CaptchaProvider::from_str(&config.arxignis.captcha.provider).unwrap_or(CaptchaProvider::HCaptcha),
                token_ttl_seconds: config.arxignis.captcha.token_ttl,
                validation_cache_ttl_seconds: config.arxignis.captcha.cache_ttl,
            };

            if let Err(e) = init_captcha_client(
                captcha_config,
            ).await {
                log::warn!("Failed to initialize captcha client: {}", e);
            } else {
                log::info!("Captcha client initialized with provider: {}", config.arxignis.captcha.provider);
                // Start captcha cache cleanup task
                start_cache_cleanup_task().await;
            }
        } else {
            log::info!("Captcha client not initialized (missing site_key, secret_key, or jwt_secret)");
        }
    } else {
        log::warn!("No API credentials provided, HTTP filter will not be initialized");
    }

    // Initialize content scanning from CLI config
    let content_scanning_config = ContentScanningConfig {
        enabled: config.content_scanning.enabled,
        clamav_server: config.content_scanning.clamav_server.clone(),
        max_file_size: config.content_scanning.max_file_size,
        scan_content_types: config.content_scanning.scan_content_types.clone(),
        skip_extensions: config.content_scanning.skip_extensions.clone(),
        scan_expression: config.content_scanning.scan_expression.clone(),
    };
    if let Err(e) = init_content_scanner(content_scanning_config) {
        log::warn!("Failed to initialize content scanner: {}", e);
    } else {
        log::info!("Content scanner initialized successfully");
    }

    // Initialize access log sender configuration
    let log_sender_config = LogSenderConfig {
        enabled: config.arxignis.log_sending_enabled,
        base_url: config.arxignis.base_url.clone(),
        api_key: config.arxignis.api_key.clone(),
        batch_size_limit: 5000,        // Default: 5000 logs per batch
        batch_size_bytes: 5 * 1024 * 1024, // Default: 5MB
        batch_timeout_secs: 10,        // Default: 10 seconds
        include_response_body: config.arxignis.include_response_body,
        max_body_size: config.arxignis.max_body_size,
    };
    set_log_sender_config(log_sender_config);

    if config.arxignis.log_sending_enabled && !config.arxignis.api_key.is_empty() {
        log::info!("Event sending to arxignis server enabled with unified queue (10s timeout, 5MB limit)");
        // Start the background unified event processor
        start_batch_event_processor();
    } else {
        log::info!("Event sending to arxignis server disabled (enabled: {}, api_key configured: {})",
                   config.arxignis.log_sending_enabled, !config.arxignis.api_key.is_empty());
    }

    let upstream_uri = {
        let parsed = config.server.upstream
            .parse::<Uri>()
            .context("failed to parse upstream URI from config")?;
        if parsed.scheme().is_none() || parsed.authority().is_none() {
            return Err(anyhow!(
                "upstream URI must be absolute (e.g. http://127.0.0.1:8081)",
            ));
        }
        parsed
    };


    // Access rules were already initialized after XDP attachment above

    // Start periodic access rules updater (if BPF is available)
    let access_rules_handle = if !state.skels.is_empty() {
        let skels = state.skels.clone();
        let api_key = config.arxignis.api_key.clone();
        let base_url = config.arxignis.base_url.clone();
        let shutdown = shutdown_rx.clone();
        Some(access_rules::start_access_rules_updater(base_url, skels, api_key, shutdown))
    } else {
        log::info!("Skipping access rules updater (XDP disabled)");
        None
    };

    // Start BPF statistics logging task
    let bpf_stats_handle = if config.bpf_stats.enabled && !state.skels.is_empty() {
        let collector = state.bpf_stats_collector.clone();
        let log_interval = config.bpf_stats.log_interval_secs;
        let shutdown = shutdown_rx.clone();
        Some(start_bpf_stats_logging(collector, log_interval, shutdown))
    } else {
        log::info!("Skipping BPF statistics logging (disabled or XDP not available)");
        None
    };

    // Start dropped IP events logging task
    let dropped_ip_events_handle = if config.bpf_stats.enabled &&
                                       config.bpf_stats.enable_dropped_ip_events &&
                                       !state.skels.is_empty() {
        let collector = state.bpf_stats_collector.clone();
        let log_interval = config.bpf_stats.dropped_ip_events_interval_secs;
        let shutdown = shutdown_rx.clone();
        Some(start_dropped_ip_events_logging(collector, log_interval, shutdown))
    } else {
        log::info!("Skipping dropped IP events logging (disabled or XDP not available)");
        None
    };

    // Start TCP fingerprinting statistics logging task
    let tcp_fingerprint_stats_handle = if config.tcp_fingerprint.enabled && !state.skels.is_empty() {
        let collector = state.tcp_fingerprint_collector.clone();
        let log_interval = config.tcp_fingerprint.log_interval_secs;
        let shutdown = shutdown_rx.clone();
        let state_clone = Arc::new(state.clone());
        Some(start_tcp_fingerprint_stats_logging(collector, log_interval, shutdown, state_clone))
    } else {
        log::info!("Skipping TCP fingerprinting statistics logging (disabled or XDP not available)");
        None
    };

    // Start TCP fingerprinting events logging task
    let tcp_fingerprint_events_handle = if config.tcp_fingerprint.enabled &&
                                           config.tcp_fingerprint.enable_fingerprint_events &&
                                           !state.skels.is_empty() {
        let collector = state.tcp_fingerprint_collector.clone();
        let log_interval = config.tcp_fingerprint.fingerprint_events_interval_secs;
        let shutdown = shutdown_rx.clone();
        let state_clone = Arc::new(state.clone());
        Some(start_tcp_fingerprint_events_logging(collector, log_interval, shutdown, state_clone))
    } else {
        log::info!("Skipping TCP fingerprinting events logging (disabled or XDP not available)");
        None
    };

    let tls_handle = {
        let mut builder = Client::builder(TokioExecutor::new());
        builder.timer(TokioTimer::new());
        builder.pool_timer(TokioTimer::new());
        let client: Client<_, Full<Bytes>> = builder.build_http();

        // Create domain filter from CLI arguments
        // Use expanded domains as the whitelist (serves dual purpose)
        let domain_filter = DomainFilter::new(
            expanded_domains.clone(),
            vec![],
        );

        if domain_filter.is_enabled() {
            log::info!(
                "Domain filtering enabled: {} whitelist entries",
                expanded_domains.len()
            );
        }

        let proxy_ctx = Arc::new(http::ProxyContext {
            client,
            upstream: upstream_uri.clone(),
            domain_filter,
            tls_only: config.tls.only,
            proxy_protocol_enabled: config.server.proxy_protocol.enabled,
            proxy_protocol_timeout_ms: config.server.proxy_protocol.timeout_ms,
            tcp_fingerprint_collector: state.tcp_fingerprint_collector.clone(),
        });

        match tls_mode {
            TlsMode::Custom => {
                let cert_path_str = config.tls.cert_path.as_ref().unwrap().clone();
                let key_path_str = config.tls.key_path.as_ref().unwrap().clone();
                let cert_path = std::path::Path::new(&cert_path_str);
                let key_path = std::path::Path::new(&key_path_str);
                let server_config = load_custom_server_config(cert_path, key_path)?;
                let tls_addrs: Vec<_> = if !config.server.tls_bind.is_empty() {
                    config.server.tls_bind.iter().map(|addr| addr.parse::<SocketAddr>().unwrap()).collect()
                } else {
                    vec![config.server.tls_addr.parse::<SocketAddr>().unwrap()]
                };

                if tls_addrs.len() > 1 { log::info!("Starting {} HTTPS listeners (custom TLS)", tls_addrs.len()); }

                let mut tasks = Vec::new();
                for bind_addr in tls_addrs {
                    let listener = TcpListener::bind(bind_addr)
                        .await
                        .with_context(|| format!("failed to bind TLS socket at {}", bind_addr))?;
                    log::info!("HTTPS proxy listening on https://{}", bind_addr);
                    let shutdown = shutdown_rx.clone();
                    let tls_state_clone = tls_state.clone();
                    let skels_clone = state.skels.clone();
                    let ctx_clone = proxy_ctx.clone();
                    let cfg = server_config.clone();
                    tasks.push(tokio::spawn(async move {
                        if let Err(err) = run_custom_tls_proxy(
                            listener,
                            cfg,
                            ctx_clone,
                            tls_state_clone,
                            skels_clone,
                            shutdown,
                        )
                        .await
                        {
                            log::error!("custom TLS proxy terminated: {err:?}");
                        }
                    }));
                }

                Some(tokio::spawn(async move {
                    for t in tasks {
                        let _ = t.await;
                    }
                }))
            }
            TlsMode::Acme => {
                let http_addrs: Vec<_> = if !config.server.http_bind.is_empty() {
                    config.server.http_bind.iter().map(|addr| addr.parse::<SocketAddr>().unwrap()).collect()
                } else {
                    vec![config.server.http_addr.parse::<SocketAddr>().unwrap()]
                };
                let tls_addrs: Vec<_> = if !config.server.tls_bind.is_empty() {
                    config.server.tls_bind.iter().map(|addr| addr.parse::<SocketAddr>().unwrap()).collect()
                } else {
                    vec![config.server.tls_addr.parse::<SocketAddr>().unwrap()]
                };

                if http_addrs.len() != tls_addrs.len() { log::warn!("ACME mode: number of HTTP bind addresses ({}) does not match HTTPS ({}) - pairing will use min length; extras will be ignored", http_addrs.len(), tls_addrs.len()); }
                let pair_count = http_addrs.len().min(tls_addrs.len());
                if pair_count == 0 { log::warn!("ACME mode: no bind addresses provided; using defaults http={} https={}", config.server.http_addr, config.server.tls_addr); }

                let mut tasks = Vec::new();
                let expanded_domains_clone = expanded_domains.clone();
                let acme_config_clone = config.acme.clone();
                let redis_config_clone = config.redis.clone();
                for i in 0..pair_count.max(1) {
                    let http_addr = http_addrs.get(i).cloned().unwrap_or(config.server.http_addr.parse().unwrap());
                    let https_addr = tls_addrs.get(i).cloned().unwrap_or(config.server.tls_addr.parse().unwrap());

                    let http_listener = TcpListener::bind(http_addr)
                        .await
                        .with_context(|| format!("failed to bind HTTP socket for ACME HTTP-01 at {}", http_addr))?;
                    let https_listener = TcpListener::bind(https_addr)
                        .await
                        .with_context(|| format!("failed to bind HTTPS socket at {}", https_addr))?;

                    log::info!("HTTP server listening on http://{} (ACME HTTP-01 + HTTP)", http_addr);
                    log::info!("HTTPS server (ACME) listening on https://{}", https_addr);

                    let tls_state_clone = tls_state.clone();
                    let shutdown = shutdown_rx.clone();
                    let _args_clone = args.clone();
                    let skels_clone = state.skels.clone();
                    let ctx_clone = proxy_ctx.clone();
                    let expanded_domains_task = expanded_domains_clone.clone();
                    let acme_config_task = acme_config_clone.clone();
                    let redis_config_task = redis_config_clone.clone();
                    tasks.push(tokio::spawn(async move {
                        if let Err(err) = run_acme_http01_proxy(
                            https_listener,
                            http_listener,
                            &acme_config_task,
                            &redis_config_task,
                            expanded_domains_task,
                            ctx_clone,
                            tls_state_clone,
                            skels_clone,
                            shutdown,
                        )
                        .await
                        {
                            log::error!("ACME HTTP-01 proxy terminated: {err:?}");
                        }
                    }));
                }

                Some(tokio::spawn(async move {
                    for t in tasks {
                        let _ = t.await;
                    }
                }))
            }
            TlsMode::Disabled => {
                // HTTP proxy for disabled TLS mode (multiple bind support)
                let http_addrs: Vec<_> = if !config.server.http_bind.is_empty() {
                    config.server.http_bind.iter().map(|addr| addr.parse::<SocketAddr>().unwrap()).collect()
                } else {
                    vec![config.server.http_addr.parse::<SocketAddr>().unwrap()]
                };

                if http_addrs.len() > 1 { log::info!("Starting {} HTTP listeners", http_addrs.len()); }

                let mut tasks = Vec::new();
                for bind_addr in http_addrs {
                    let listener = TcpListener::bind(bind_addr)
                        .await
                        .with_context(|| format!("failed to bind HTTP socket at {}", bind_addr))?;
                    log::info!("HTTP proxy listening on http://{}", bind_addr);
                    let shutdown = shutdown_rx.clone();
                    let skels_clone = state.skels.clone();
                    let ctx_clone = proxy_ctx.clone();
                    tasks.push(tokio::spawn(async move {
                        if let Err(err) = run_http_proxy(
                            listener,
                            ctx_clone,
                            skels_clone,
                            shutdown,
                        )
                        .await
                        {
                            log::error!("HTTP proxy terminated: {err:?}");
                        }
                    }));
                }

                Some(tokio::spawn(async move {
                    for t in tasks {
                        let _ = t.await;
                    }
                }))
            }
        }
    };

    // Start health check server
    let health_check_handle = {
        let shutdown = shutdown_rx.clone();
        let health_config = config.server.health_check.clone();
        tokio::spawn(async move {
            if let Err(err) = start_health_check_server(health_config, shutdown).await {
                log::error!("Health check server error: {}", err);
            }
        })
    };

    signal::ctrl_c().await?;
    log::info!("Shutdown signal received, stopping servers...");
    let _ = shutdown_tx.send(true);

    if let Some(handle) = tls_handle
        && let Err(err) = handle.await
    {
        log::error!("TLS task join error: {err}");
    }

    if let Some(handle) = access_rules_handle
        && let Err(err) = handle.await
    {
        log::error!("access-rules task join error: {err}");
    }

    if let Some(handle) = bpf_stats_handle
        && let Err(err) = handle.await
    {
        log::error!("bpf-stats task join error: {err}");
    }

    if let Some(handle) = dropped_ip_events_handle
        && let Err(err) = handle.await
    {
        log::error!("dropped-ip-events task join error: {err}");
    }

    if let Some(handle) = tcp_fingerprint_stats_handle
        && let Err(err) = handle.await
    {
        log::error!("tcp-fingerprint-stats task join error: {err}");
    }

    if let Some(handle) = tcp_fingerprint_events_handle
        && let Err(err) = handle.await
    {
        log::error!("tcp-fingerprint-events task join error: {err}");
    }

    if let Err(err) = health_check_handle.await {
        log::error!("health-check task join error: {err}");
    }

    // Detach XDP programs from interfaces
    if !ifindices.is_empty() {
        log::info!("Detaching XDP programs from {} interfaces...", ifindices.len());
        for ifindex in ifindices {
            if let Err(e) = bpf_utils::bpf_detach_from_xdp(ifindex) {
                log::error!("Failed to detach XDP from interface {}: {}", ifindex, e);
            }
        }
    }

    Ok(())
}

/// Start a background task that logs BPF statistics periodically
fn start_bpf_stats_logging(
    collector: BpfStatsCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_stats() {
                        log::warn!("Failed to log BPF statistics: {}", e);
                    }
                }
            }
        }

        log::info!("BPF statistics logging task stopped");
    })
}

/// Start a background task that logs dropped IP events periodically
fn start_dropped_ip_events_logging(
    collector: BpfStatsCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_dropped_ip_events() {
                        log::warn!("Failed to log dropped IP events: {}", e);
                    }
                }
            }
        }

        log::info!("Dropped IP events logging task stopped");
    })
}

/// Start a background task that logs TCP fingerprinting statistics periodically
fn start_tcp_fingerprint_stats_logging(
    collector: TcpFingerprintCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
    _state: Arc<AppState>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_stats() {
                        log::warn!("Failed to log TCP fingerprinting statistics: {}", e);
                    }
                }
            }
        }

        log::info!("TCP fingerprinting statistics logging task stopped");
    })
}

/// Start a background task that logs TCP fingerprinting events periodically
fn start_tcp_fingerprint_events_logging(
    collector: TcpFingerprintCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
    _state: Arc<AppState>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_fingerprint_events() {
                        log::warn!("Failed to log TCP fingerprinting events: {}", e);
                    }
                }
            }
        }

        log::info!("TCP fingerprinting events logging task stopped");
    })
}
